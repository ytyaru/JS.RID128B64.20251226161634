# AIへの実装要求

　JavaScript言語で次のコードを実装してください。暗号論的安全乱数で作成されたランダムIDを返す関数とクラスを実装してください。仕様は次の通りです。

```javascript
export const id = (head='RID128R64', nextInt=0n)=>{...};
export class ID {
    static get(head='RID128R64', nextInt=0n) {...};
    static convert(ins, head) {...}
}
```

　`id`関数は`head`で指定した仕様のBaseN文字列を生成します。`ID.get()`メソッドは`head`で指定した仕様のBaseNクラスインスタンスを返します。その仕様は以下です。

```javascript
class BaseN {
    get full() {...}
    get head() {...}
    get body() {...}
}
class BaseNString {
    constructor(head, body) {...}
    get head() {...}
    get body() {...}
    set body(v) {...}
}
class BaseNStringBody {
    get str() {...}
    get u8a() {...}
    get int() {...}
    set str(v) {...}
    set u8a(v) {...}
    set int(v) {...}
}
class BaseNStringHead {
    constructor(type, bits, radix, sortabled=false, urlUnsafed=false, visibled=false, padded=false) {...}
    get type() {...}
    get bits() {...}
    get radix() {...}
    get sortabled() {...}
    get urlUnsafed() {...}
    get visibled() {...}
    get padded() {...}
    get str() {...} // 'RID128R64SUVP'のような文字列を返す
}
```

　`head`には次のような属性があります。

属性|概要
----|----
`type`|IDの種別。`RID`(RandomID), `TID`(TimeID), `IID(IncrementID)`の三種を想定。
`bits`|データ量。`Uint8Array(bits*8)`でデータを持つ。
`radix`|基数。IDの字種数と同じ。(2〜64, 256, 1048576のみ)
`sortabled`|ID文字列がデータ値と同様に並替できるか。（データを文字に置換する時、その文字はASCIIコード順か。例えばradix=64時、sortabledがfalseなら`A-Za-z0-9\-_`、trueなら`\-0-9A-Z_a-z`の文字列を使って変換する）
`urlUnsafed`|URL安全な文字以外を使用するか否か。（radix=64時のみ有効。もしtrueなら使用する記号を`+/`にする）
`visibled`|視認性の低い文字列を削除するか否か。（詳細後述）
`padded`|`=`でパディングするか否か。

　`radix`が`256`の時、ID仕様文字列は`⠀⢀⠠⢠⠐⢐⠰⢰⠈⢈⠨⢨⠘⢘⠸⢸⡀⣀⡠⣠⡐⣐⡰⣰⡈⣈⡨⣨⡘⣘⡸⣸⠄⢄⠤⢤⠔⢔⠴⢴⠌⢌⠬⢬⠜⢜⠼⢼⡄⣄⡤⣤⡔⣔⡴⣴⡌⣌⡬⣬⡜⣜⡼⣼⠂⢂⠢⢢⠒⢒⠲⢲⠊⢊⠪⢪⠚⢚⠺⢺⡂⣂⡢⣢⡒⣒⡲⣲⡊⣊⡪⣪⡚⣚⡺⣺⠆⢆⠦⢦⠖⢖⠶⢶⠎⢎⠮⢮⠞⢞⠾⢾⡆⣆⡦⣦⡖⣖⡶⣶⡎⣎⡮⣮⡞⣞⡾⣾⠁⢁⠡⢡⠑⢑⠱⢱⠉⢉⠩⢩⠙⢙⠹⢹⡁⣁⡡⣡⡑⣑⡱⣱⡉⣉⡩⣩⡙⣙⡹⣹⠅⢅⠥⢥⠕⢕⠵⢵⠍⢍⠭⢭⠝⢝⠽⢽⡅⣅⡥⣥⡕⣕⡵⣵⡍⣍⡭⣭⡝⣝⡽⣽⠃⢃⠣⢣⠓⢓⠳⢳⠋⢋⠫⢫⠛⢛⠻⢻⡃⣃⡣⣣⡓⣓⡳⣳⡋⣋⡫⣫⡛⣛⡻⣻⠇⢇⠧⢧⠗⢗⠷⢷⠏⢏⠯⢯⠟⢟⠿⢿⡇⣇⡧⣧⡗⣗⡷⣷⡏⣏⡯⣯⡟⣟⡿⣿`とする。

　`radix`が`1048576`の時、ID仕様文字列は安全なコードポイントだけを使ったUnicode文字列であること。20bit分のデータを1文字に変換するものとする。

　`visibled`フラグで示す視認性の低い紛らわしい文字は`0O1Il8B`である。渡した`radix`値に応じて、削除すべき紛らわしい文字を返す関数は以下。これを使ってID使用文字列を作ること。

```javascript
    static #getConfusingChars(radix=55) {
        return 62 <=radix ? '' : (
               61===radix ? '0' : (
               60===radix ? '01' : (
               59===radix ? '1Il' : (
               58===radix ? '0OIl' : (
               57===radix ? '0O1Il' : (
               56===radix ? '0O1Il8' :
               56===radix ? '0O1Il8' : '0O1Il8B'))))));
    }
```

　`type`には以下の3種類ある。

* RIDは全bitsを暗号論的安全乱数で生成する
* TIDは先頭48bitsをエポックタイムで埋め、残りビット数を暗号論的安全乱数で生成する
* IIDは指定した整数から一つずつ増やしていく。これだけは`next()`メソッドを持っておりインクリメントしたインスタンスを返す

　`head`文字列の仕様は以下。

```
{R|T|I}ID{bits}R{radix}{flag}-{乱数}
```
```
RID128R64SUVP-乱数
```

　以下はBase1048576。20bitをUnicodeの1字にする。

```
RID128U-乱数
```

　bitsは省略時128とする。bitsを省略すると`R`も省略できる。

```
RID64SUVP-乱数
```

　radixは省略時64とする。

```
RIDSUVP-乱数
```

　flags`SUVP`は全て`false`だと消える。`true`のフラグだけ`S`,`U`,`V`,`P`が付与される。それぞれ`sortabled`, `urlUnsafed`, `visibled`, `padded`フラグに相当する。

```
RID-乱数
```

　呼出コード例は以下。

```javascript
id() // 文字列を返す
id('RID128R64SUVP') // 文字列を返す
```
```javascript
const R = ID.get(); // インスタンスを返す
const R = ID.get('RID128R64UP'); // インスタンスを返す
R.valid(base64str);
R.str = base64str;
R.str; // String
R.u8a; // Uint8Array
R.int; // BigInt
R.full; // RID128R64UP-乱数
R.head; // RID128R64UP
const S = ID.convert(R, 'RID256R32');
S.valid(base32str);
S.str = base32str;
S.str; // String値
S.u8a; // Uint8Array値
S.int; // BigInt値
S.full; // RID256R32-乱数
R.head; // RID256R32
```

```javascript
id(); // 128bitsBase64URL風文字列を返す
id('RID128R64SUVP');
id('TID32');
id('IID36', 8n);
ID.get('RID128R64SUVP').body.str; // 128bitsBase64URL風文字列を返す
ID.convert(ID.get('RID128R64SUVP'), 'RID32').body.str; // 128bitsBase64URL風文字列をBase32風文字列に変換する
```

　尚、Baseパターンが多いためなるだけ共通部分は同じ計算方法で実装したい。だが共通化できない場合や、よく使うであろうBase64/Base64URLは組込APIで高速化したい。よってその4つは独自に以下内部クラスで実装する。

```javascript
class Base64 {}
class Base64URL extends Base64 {}
class Base256 {}
class Base1048576 {}
```

　その他のパターンは文字列、Uint8Array、BigIntにより算出可能なはず。その基礎として以下のような計算用APIを書いた。これを使って`BaseN`クラスを実装して欲しい。

```javascript
class ValidStr {
    static valid(str, name, REG) {
        if ('string'!==typeof str) {throw new TypeError(`${name}はString値であるべきです。`)}
        if (str.match(REG)) {throw new TypeError(`${name}は正規表現${REG}に従ったString値であるべきです。`)}
        return true;
    }
}
class B64UStr extends ValidStr {
    static valid(str, isURL) {super.valid(str, `Base64URL`, /^[A-Za-z0-9\-_]+$/); return this.#calcBase64Padding(base64URL);}
    static toBase64(base64URL, padNum) {return base64URL.replaceAll('-','+').replaceAll('_','/') + '='.repeat(padNum ?? this.#calcBase64Padding(base64URL))}
    static #calcBase64Padding(base64URL) {
        const L = base64URL.length; // Base64URL文字列の長さ (パディングなし)
        const R = length % 4; // 長さを4で割った余りを計算
        if (1===R) {throw new TypeError(`Base64URLは無効な長さです。`)}
        return 0===R ? 0 : (2===R ? 2 : 1);
    }
}
class B64Str extends ValidStr {
    static valid(str, isURL) {return super.valid(str, `Base64`, /^[A-Za-z0-9\+\/]+$/)}
    static toU8a(str) {
        const binStr = atob(str);
        const bytes = new Uint8Array(binStr.length);
        for (let i=0; i<binStr.length; i++) {bytes[i] = binStr.charCodeAt(i);}
        return bytes;
    }
    static toInt(str) {return B64U8a.toIntBE(this.toU8a(str))}
    static toBase64URL(str) {return str.replaceAll('+','-').replaceAll('/','_').replaceAll('=','')}
}
class B64U8a {
    static toStr(u8a) {return 'function'===typeof bytes.toBase64 ? bytes.toBase64() : btoa(String.fromCharCode(...bytes))}
    static toInt(u8a, isLE=false) {// Uint8Array→BigInt(エンディアン選択可)
        let result = BigInt(0);
        const len = u8a.length;
        for (let i=0; i<len; i++) {
            const index = isLE ? (len - 1 - i) : i;
            result = (result << 8n) + BigInt(u8a[index]);
        }
        return result;
    }
    static toIntBE(u8a) {return this.toInt(u8a, false)} // ビッグエンディアン
    static toIntLE(u8a) {return this.toInt(u8a, true)} // リトルエンディアン
}
class B64Int {
    static toStr(int) {
        // 1. BigIntを16進数文字列に変換 (先頭の '0x' は除去)
        const hexString = int.toString(16);
        // 2. 16進数文字列をバイト配列 (Uint8Array) に変換
        // 16進数1文字は4ビット、2文字で1バイトなので、文字列の長さは偶数にする必要あり
        const paddedHexString = hexString.length % 2 === 0 ? hexString : '0' + hexString;
        const bytes = new Uint8Array(paddedHexString.length / 2);
        for (let i = 0; i < paddedHexString.length; i += 2) {
            bytes[i / 2] = parseInt(paddedHexString.substring(i, i + 2), 16);
        }
        // 3. バイト配列をバイナリ文字列に変換し、btoaでBase64エンコード
        let binaryString = '';
        bytes.forEach(byte => {
            binaryString += String.fromCharCode(byte);
        });
        return btoa(binaryString); // ブラウザ環境の場合。Node.jsではBufferを使う
    }
    static toU8a(int, isLE=false) {// BigInt→Uint8Array（エンディアン選択可）
        let hex = int.toString(16);
        if (hex.length % 2 !== 0) {hex = '0' + hex;} // 長さを偶数に調整
        const len = hex.length / 2;
        const u8a = new Uint8Array(len);
        for (let i=0; i<len; i++) {
            const index = isLE ? i : len - 1 - i; // (リトル|ビッグ)エンディアン切替
            u8a[index] = Number(int & 0xffn);
            int >>= 8n;
        }
        return u8a;
    }
    static toU8aBE(int) {return this.toU8a(int,false)} // ビッグエンディアン
    static toU8aLE(int) {return this.toU8a(int,true)} // リトルエンディアン
    static getPaddingNum(I, radix=64) {// 値Iが基数radixの時、必要なパディング数を返す（I,radixはBigInt型。戻り値はNumber型）
        if (0n===I) {return 1;} // 0または1を扱う特殊なケース
        let [padding,power] = [0n,1n];
        if ('bigint'!==radix) {radix = BigInt(radix)}
        while (power <= I) {power *= radix; padding++;}
        return Number(padding); // パディング数はNumber型で返しても一般的に問題ない
    }
}
```

　Base16/32/58も使用頻度がそれなりにあるはず。これに関しては先述の計算メソッドよりも専用処理を実装したほうが高速だと思われる。よってそれらについても専用クラスで処理を実装して欲しい。

