# ID

種類|概要
----|----
RID|分散システムで使用するID。128bits等任意サイズの乱数をBase64URLなど文脈で使用可能な文字だけで構成された文字列。
IID|中央システムで使用するID。ソート可能な連番。（0から始まる整数であり+1する）
TID|中央システムで使用するID。ソート可能な非連番（先頭bitsが日時(Time)、後方bitsが乱数）。RDBMSファイルB木構造やURLで共用可だが日時が表出してしまう。

形式|概要
----|----
コマンド|CUIコマンド形式で文字列を返す
WebAPI|JSONを返す
関数|JS関数で文字列を返す
クラス|String,BigInt,Uint8Array形式を返す

## コマンド

```sh
$ rid 
-b --bits  8以上な2の冪乗数（初期値128）
-B --base  使用字種数（初期値64)
  2〜64        6bit以下ずつURLセーフ文字に変換する(字数=bits/6, 字bits=bits*(4/3))
  256          8bitずつUnicode点字(4Byte)に変換する(字数=bits/8, 字bits=bits*4)
  65565        16bitずつUnicode2Byte文字に変換する(字数=bits/16, 字bits=bits*1)
  任意文字列   重複のない任意文字列("0123456789ABCDEF"等)
-S --sortable    文字はASCII昇順である（初期値false） -B16 -S で Base16
-V --visibility  視認性の低い文字を抜く               -B32 -V で Base32, -B58 -V で Base58
```

　使用文字は`[A-Za-z0-9\-_]+`が基本だが、場合によっては視認性の悪い字を抜く場合もある。たとえばBase32, Base58等。またBase16は0から始まるため、それに合わせて`[0-9A-Za-z]`にしたい場合がある。Base64URLは`[A-Za-z0-9\-_]`だが値の大小と一致する並替を可能にすべく`[\-0-9A-Z_a-z]+`にしたい場合がある。そのときは`-S`フラグを付与する。

```

```

* base32（0189除外）
    * Hex
* base58（）
    * 


## WebAPI

### `get`

```
GET /get.html
```
```javascript
"ランダムID文字列"
```
```javascript
{
  head: "rid128b64",
  body: "ランダムID文字列"
}
```
```javascript
{
  type: "rid",
  bits: 128,
  base: 64,
  body: "ランダムID文字列"
}
```
```javascript
{
  type: "tid",
  bits: 128,
  base: 64,
  body: {
    all: "ランダムID文字列",
    time: {
      str: "yyyy-mm-dd HH:MM:SS.FFF",
      int: {
        year: 2025,
        month: 12,
        days: 31,
        hours: 23,
        minutes: 59,
        seconds: 59,
        milSecs: 999,
      },
      bigint: "0xFFFFFFFFFFFFFFFFFFF", // エポックタイム
    },
    rnd: "ランダム部分", // Number型は53bit迄。JSONはBigInt非対応のため"0xFFFFFFFFFFFFFFFFFF"のようにしてBigInt("0xFF...")とパースする。
  }
}
```

引数|型|初期値|有効値
----|--|------|------
`type`|`str`|`rid`|`rid`/`tid`
`bits`|`int`|`128`|8以上な2の冪乗(8,16,32,64,128,256,512,...)
`base`|`int`|`64`|2〜64,256,65536

### `gets`

```
GET /get.html?num=5
```

```javascript
[
  "ランダムID文字列",
  ...,
  "ランダムID文字列",
]
```
```javascript
{
  type: "rid128b64",
  items: [
    "ランダムID文字列"
    ...,
    "ランダムID文字列"
  ]
}
```

引数|型|初期値|有効値
----|--|------|------
`bits`|`int`|`128`|8以上な2の冪乗(8,16,32,64,128,256,512,...)
`base`|`int`|`64`|2〜64,256,65536
`num`|`int`|`1`|1〜100

## 関数

```javascript
rid(base=64, bits=128); // ID文字列を返す
iid(next=0n, base=64); // ID文字列を返す
```

## クラス

```javascript
class RID {...}
const rid = new RID(base=64, bits=128);
rid.str; // 文字列 ...
rid.int; // BigInt ...
rid.u8a; // Uint8Array ...
rid.full; // 文字列 rid128b64-... bitsやbaseをヘッダとして記述する
RID.convert(value, base, bits); // 他のBaseやbitsにした時のRIDインスタンスを返す

class IID {...}
const iid = new IID(next=0n, base=64);
iid.next(); // 次に進める
iid.int; // BigIntで現在値を取得する
iid.str; // Stringで現在値を取得する
iid.u8a; // Uint8Arrayで現在値を取得する
IID.convert(value, base); // 他のBaseやbitsにした時のIIDインスタンスを返す
```

## Base戦略

Base|ID字数|ID字bits|概要
----|------|--------|----
65565|bits/16|bits*1|IDデータ量最小だがUnicode2バイト文字なので可読性が悪く非URLセーフ
256|bits/8|bits*4|ID字数は少ないがデータ量最大で非URLセーフ
64|bits/6|bits/6|URLセーフで高速計算可だがIDの字数やbitsは増加する
62|bits/5.9|bits/5.9|記号セーフだがIDの字数やbitsは増加する
36|bits/5.1|bits/5.1|英字大小セーフだがIDの字数やbitsは増加する
32|bits/5|bits/5|英字大小セーフだがIDの字数やbitsは増加する
16|bits/4|bits/4|英字大小セーフで高速計算可だがIDの字数やbitsは増加する
10|bits/3.3|bits/3.3|英字セーフだがIDの字数やbitsは増加する

```javascript
const IdCharNum = bits / Math.log2(base);
```

## 日時バイナリ構成

項目|bits|最小|別|別|別
----|----|----|--|--|--
year|16|16|32|32|32|32
month|8|4|4|8|8
days|8|5|5|8|8
hours|8|5|5|8|8
minutes|8|6|6|8|8
seconds|8|6|6|8|8
millSec|0|0|0|0|8
乱数|70|84|68|56|48

　56bitの乱数が衝突する確率。誕生日のパラドクスにあるように、生成数が増えると急激に衝突率が増加する。n個生成した時に一致する確率。約3億1665万個生成した時、衝突率50%を超える。

```mathml
\(n\approx \sqrt{2^{56}\times \ln (2)}\approx 1.18\times \sqrt{2^{56}}=1.18\times 2^{28}\)
```

　同一システム上において世界中の人々がIDを同時生成しうるとして、一秒間に3億個生成すれば50%の確率で一致する。おそらくそんなことは起きない。

## 複数ID形式が混在する場合

* メタデータ付与
* 固定長
* チェックサム（Base58Check方式。データの末尾にデータのハッシュ値（SHA256を二回掛けたもの）を付ける）

### メタデータ

```
{R|T|I}ID{bits}R{radix}{flag}-{乱数}
```
```
RID128R64SUVP-乱数
```

　以下はBase1048576。20bitをUnicodeの1字にする。

```
RID128U-乱数
```

　bitsは省略時128とする。bitsを省略すると`R`も省略できる。

```
RID64SUVP-乱数
```

　radixは省略時64とする。

```
RIDSUVP-乱数
```

　flags`SUVP`は全て`false`だと消える。

```
RID-乱数
```

　このメタデータ文字列からランダムIDを生成したい。

```javascript
id() // 文字列を返す
id('RID128R64SUVP') // 文字列を返す
```
```javascript
const R = ID.get(); // インスタンスを返す
const R = ID.get('RID128R64UP'); // インスタンスを返す
R.valid(base64str);
R.str = base64str;
R.str; // String
R.u8a; // Uint8Array
R.int; // BigInt
R.full; // RID128R64UP-乱数
R.head; // RID128R64UP
const S = ID.convert(R, 'RID256R32');
S.valid(base32str);
S.str = base32str;
S.str; // String値
S.u8a; // Uint8Array値
S.int; // BigInt値
S.full; // RID256R32-乱数
R.head; // RID256R32
```

```javascript
id() // 文字列を返す
id('RID128R64SUVP') // ランダムID
id('TID128R64SUVP') // 先頭に日時を付与したランダムID
id('IID128R64SUVP', next=0) // +1する連番ID
```
```javascript
const R = ID.get(); // インスタンスを返す
const R = ID.get('IID128R64UP', next=5); // インスタンスを返す
R.valid(base64str);
R.str = base64str;
R.u8a; // Uint8Array
R.int; // BigInt
const S = ID.convert(R, 'IID256R32');
S.valid(base32str);
S.str = base32str;
S.u8a; // Uint8Array
S.int; // BigInt
```

```javascript
rid() // 文字列を返す
rid('128R64SUVP') // 文字列を返す
```
```javascript
const R = RID.get(); // インスタンスを返す
const R = RID.get('128R64UP'); // インスタンスを返す
R.valid(base64str);
R.str = base64str;
R.u8a; // Uint8Array
R.int; // BigInt
const S = RID.convert(R, '256R32');
S.valid(base32str);
S.str = base32str;
S.u8a; // Uint8Array
S.int; // BigInt
```

### バイナリデータにメタデータを付与してもダメ

　任意文字セットによる変換は対象外になってしまうが、以下情報をバイナリデータに含めれば復元可能か？　パディングは無しとする。

* type(1Byte:0〜255): randomID/timeID/incrementID/将来の拡張に備える
* bytes(1Byte:0〜255): データサイズ長。現代では128bits(16bytes)。
* radix(1Byte:0〜255): 使用文字種数。任意文字セットは使用不可。基本的に出力IDが並替可能なようにASCIIコード順`[\-0-9A-Z_a-z]`である（既存Base64URL規格とは異なる順序である点に注意。64以降で有効なのは256と1048576のみ。256は点字を使うためID文字列バイト数は元データの4倍になる。1048576は20bitを1字にする）
* flags(1Byte(4bitのみ使用))
	* sortable(1Byte中1bit:0,1): 出力ID文字列をコードポイントの昇順に並べ替えるか否か（初期値false）
	* urlUnsafed(1Byte中1bit:0,1): URLでそのまま表現できない文字列を使用するか（初期値false）
	* visibility(1Byte中1bit:0,1): 視認性の低い字を抜くか否か（初期値false）
	* padded(1Byte中1bit:0,1): 端数を=で埋めるか否か（初期値false）
* random(可変長): bytesの長さの文だけ暗号論的安全乱数を生成した領域。

　バイナリ構造は以下。

```
[type][bytes][radix][flags][乱数領域(可変長)]
```

　このバイナリデータをBase64URL化する。先頭4Byteに情報を付与する形。

　でもこれではID文字列がBase64URLで固定化されてしまう。そこを可変にしたい。でも好き勝手なBaseNにしたら、それがBaseいくつか判断できない。よってこの方法では混在できない。

