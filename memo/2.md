# メタデータ実装要求

js 暗号論的安全乱数を使いデータ量bitsや基数radixなどを指定した文字列を示したい。例えば以下のように。

```javascript
RID128R64-uUKC2RIZ5Yi3a8erpCc6-g
```

　これはランダムID128bitsデータ量を持ち64字種を用いて表現したことを意味する。

　わざわざ文字列の先頭にメタデータを付与したのは、異なる形式のIDを混在させることを可能にするため。大凡次のような構造になる。

```
{type}ID{bits}R{radix}{flag}-{random}
```
```
RID{bits}R{radix}{flag}-{random}
```
```
IID{bits}R{radix}{flag}-{random}
```
```
TID{timeBits}-{randBits}R{radix}{flag}-{random}
```

変数|値
----|--
`{type}`|`R`,`T`,`I`のいずれか
`{bits}`|`8`以上の整数（データ量）
`{radix}`|`2`〜`64`, `256`, `U`のいずれか
`{flag}`|使用文字種やその順序を指定するフラグ（詳細後述）
`{random}`|乱数文字列

変数|値
----|--
`{timeBits}`|UNIX時刻の表現ビット数(48bits〜)
`{randBits}`|暗号論的安全乱数の表現ビット数

　`{flag}`には`SUVP`の文字が入りうる。`true`なら含まれ、`false`なら含まれない。

`{flag}`|単語|概要
--------|----|----
`S`|`sortable`|ID使用文字をASCIIコード順にするか否か（初期値false）
`U`|`urlUnsafed`|ID使用文字をURLセーフな文字以外を使用するか否か。`radix`=64時のみ`true`にすると使用記号が`+/`になる（初期値false）
`V`|`visibled`|ID使用文字から視認性の低い文字を除外するか否か（初期値false）
`P`|`padded`|乱数部末尾を`=`でパディングするか否か（初期値false）

　先頭にあるメタデータが妥当な文字列であるか判断するコードをJavaScriptで実装したい。

　但し、なるだけ短く表現できるよう、各部位を省略できるようにする。また、いくつか特殊形式もあるものとする。

　以下はBase1048576。20bitをUnicodeの1字にする。以下はbits=128, radix=1048576である。`F`の時は`Full`の略。

```
RID128F-乱数
```

　bitsは省略時128とする。bitsを省略すると`R`も省略できる。以下はbits=32でなくradix=32である。

```
RID32SUVP-乱数
```

　radixは省略時64とする。

```
RIDSUVP-乱数
```

　尚、先頭一字目はIDの種別を意味し、`R`,`T`,`I`の3種類ある。それぞれ以下の通り。

先頭|単語|概要
----|----|----
`R`|`Random`|全bitsを暗号論的安全乱数で生成する
`T`|`Timed`|先頭48bitsをUNIXタイムで、残りを暗号論的安全乱数で生成する
`I`|`Increment`|+1ずつの連番で生成する

　以上の仕様で文字列の先頭に付与されたメタデータ文字列が妥当か判断するコードをJavaScriptで書いてください。

```javascript
/**
 * IDメタデータの妥当性を判定し、解析結果を返す
 * @param {string} metaString - ハイフンより前のメタデータ部分
 * @returns {object|null} 妥当なら解析オブジェクト、不当ならnull
 */
function parseIdMetadata(metaString) {
    // 正規表現の解説:
    // ^([RTI]) : 先頭はR, T, Iのいずれか
    // (?:ID)?  : "ID" という文字列（省略可）
    // (\d+)?   : bits数値（省略可）
    // (?:R(\d+|U)|F)? : radix ("R" + 数値/U) または "F" (Base1048576)（省略可）
    // ([SUVP]*) : フラグ群（省略可）
    // $
    const pattern = /^([RTI])(?:ID)?(\d+)?(?:R(\d+|U)|(F))?([SUVP]*)$/;
    const match = metaString.match(pattern);

    if (!match) return null;

    let [_, type, bits, radix, isFull, flags] = match;

    // 1. bits の判定とデフォルト値
    // 省略時は128。TIDの場合は timeBits-randBits の形式だが、
    // ここでは全体ビット数として抽出される
    bits = bits ? parseInt(bits, 10) : 128;
    if (bits < 8) return null;

    // 2. radix の判定
    let finalRadix;
    if (isFull) {
        finalRadix = 1048576; // 'F' の場合
    } else if (radix === 'U') {
        finalRadix = 'U'; // 特殊指定
    } else if (radix) {
        finalRadix = parseInt(radix, 10);
        if (!((finalRadix >= 2 && finalRadix <= 64) || finalRadix === 256)) return null;
    } else {
        finalRadix = 64; // デフォルト
    }

    // 3. フラグの重複チェック
    const flagSet = new Set(flags);
    if (flagSet.size !== flags.length) return null;

    // 4. TID (Timed) の特殊制約
    // 仕様: timeBits(48-) + randBits が bits となる
    // ここでは単一数値としてパースされるため、最低48+乱数分のビットが必要
    if (type === 'T' && bits < 48) return null;

    return {
        type,
        bits,
        radix: finalRadix,
        flags: {
            S: flagSet.has('S'),
            U: flagSet.has('U'),
            V: flagSet.has('V'),
            P: flagSet.has('P')
        }
    };
}

/**
 * 簡易的な検証用関数
 */
function isValidMetadata(metaString) {
    return parseIdMetadata(metaString) !== null;
}

// --- テストケース ---
const testCases = [
    "RID128R64",      // 標準
    "RID128R64uUKC",  // NG (フラグ以外の文字)
    "RID128F",        // Full形式 (Base1048576)
    "RID32SUVP",      // bits省略なし、radix省略(64) + フラグ
    "RIDSUVP",        // bits省略(128)、radix省略(64) + フラグ
    "TID64R32S",      // Timed ID
    "RID8R2",         // 最小ビット
    "RID7R2",         // NG (8bits未満)
    "RID128RU",       // radix U 指定
    "RID128R256P"     // radix 256 + Padded
];

testCases.forEach(tc => {
    console.log(`${tc.padEnd(15)} : ${isValidMetadata(tc) ? "✅ Valid" : "❌ Invalid"}`);
});
```

# 追加要求

　`timeBitsと`randBits`は分離した形で全体を修正してください。そのとき`return`するオブジェクトのプロパティ`bits`の内容は`bits:{time:N, random:N}`としてください。

```javascript
/**
 * IDメタデータの妥当性を判定し、詳細な構成を返す
 * @param {string} metaString - ハイフン（乱数セパレータ）より前の文字列
 * @returns {object|null} 妥当なら解析オブジェクト、不当ならnull
 */
function parseIdMetadata(metaString) {
    // 正規表現の構成:
    // 1. ([RTI]) : Type (R, T, I)
    // 2. (?:ID)? : "ID"文字列（省略可）
    // 3. (\d+(?:-\d+)?)? : bits部分。数字、または "数字-数字" (省略可)
    // 4. (?:R(\d+|U)|(F))? : Radix部分。"R" + 数値/U、または "F" (省略可)
    // 5. ([SUVP]*) : Flags部分 (省略可)
    const pattern = /^([RTI])(?:ID)?(\d+(?:-\d+)?)?(?:R(\d+|U)|(F))?([SUVP]*)$/;
    const match = metaString.match(pattern);

    if (!match) return null;

    let [_, type, bitsPart, radixNum, isFull, flagsStr] = match;

    // --- bits の解析 ---
    let bits = { time: 0, random: 0 };
    
    if (type === 'T') {
        // Timed ID の場合
        if (bitsPart && bitsPart.includes('-')) {
            const [t, r] = bitsPart.split('-').map(Number);
            bits.time = t;
            bits.random = r;
        } else {
            // bits省略時、または数値一つの指定時はデフォルト
            // 数値一つの指定(TID128等)は、仕様上timeBitsが48固定か全体が指定値か曖昧なため、
            // ここでは timeBits=48, 残りを指定値(計128ならrandom=80)とする例
            const total = bitsPart ? parseInt(bitsPart, 10) : 128;
            bits.time = 48;
            bits.random = total - 48;
        }
        // 制約: timeBitsは48以上
        if (bits.time < 48 || bits.random < 0) return null;
    } else {
        // Random (R) または Increment (I) の場合
        if (bitsPart && bitsPart.includes('-')) return null; // RやIでハイフン形式は不可
        bits.random = bitsPart ? parseInt(bitsPart, 10) : 128;
        if (bits.random < 8) return null;
    }

    // --- radix の解析 ---
    let radix;
    if (isFull) {
        radix = 1048576;
    } else if (radixNum === 'U') {
        radix = 'U';
    } else if (radixNum) {
        radix = parseInt(radixNum, 10);
        const allowed = (radix >= 2 && radix <= 64) || radix === 256;
        if (!allowed) return null;
    } else {
        radix = 64; // デフォルト
    }

    // --- flags の解析 ---
    const flagSet = new Set(flagsStr);
    if (flagSet.size !== flagsStr.length) return null; // 重複禁止

    return {
        type,
        bits,
        radix,
        flags: {
            S: flagSet.has('S'),
            U: flagSet.has('U'),
            V: flagSet.has('V'),
            P: flagSet.has('P')
        }
    };
}

// --- テスト ---
let testCases = [
    "RID128R64",        // Rタイプ: bits.random=128
    "TID48-80R64",      // Tタイプ: bits.time=48, random=80
    "TID64-64SU",       // Tタイプ: radix省略(64), フラグあり
    "RIDSUVP",          // Rタイプ: 省略形 (bits.random=128, radix=64)
    "RID128F",          // Full (radix=1048576)
    "IID256R256",       // Iタイプ
    "TID32-64R64",      // NG (timeBits < 48)
    "RID48-64R64",      // NG (Rタイプでハイフン指定)
    "RID",
];

testCases.forEach(tc => {
    const result = parseIdMetadata(tc);
    console.log(`${tc.padEnd(15)} : ${result ? JSON.stringify(result) : "❌ Invalid"}`);
});
```

# 追加要求

　同様に、`parseIdMetadata()`関数が返すオブジェクトの値からメタデータ文字列を返す関数を実装してください。

```javascript
/**
 * 解析オブジェクトからメタデータ文字列を生成する
 * @param {object} obj - type, bits, radix, flags を持つオブジェクト
 * @returns {string} メタデータ文字列
 */
function stringifyIdMetadata(obj) {
    const { type, bits, radix, flags } = obj;
    let res = type + "ID";

    // --- bits 部分の生成 ---
    if (type === 'T') {
        // Timed ID の場合
        // デフォルト (48-80 = 合計128) なら省略可能だが、
        // 明示的な指定がある場合は {time}-{random} 形式
        if (bits.time === 48 && bits.random === 80) {
            // 省略可能
        } else {
            res += `${bits.time}-${bits.random}`;
        }
    } else {
        // Random / Increment の場合
        // デフォルト 128 なら省略可能
        if (bits.random !== 128) {
            res += bits.random;
        }
    }

    // --- radix 部分の生成 ---
    if (radix === 1048576) {
        res += "F";
    } else if (radix === 'U') {
        res += "RU";
    } else if (radix === 64) {
        // デフォルト 64 なら省略
    } else if (radix) {
        res += "R" + radix;
    }

    // --- flags 部分の生成 ---
    // flags: { S: true, U: false, ... } の形式を想定
    if (flags) {
        ['S', 'U', 'V', 'P'].forEach(f => {
            if (flags[f]) res += f;
        });
    }

    // 仕様に基づき、"RID" 自体も bits 等が省略されていれば "RID" のまま、
    // あるいはさらに短縮可能だが、識別子として "ID" は残す実装としています。
    // ※もし「bits省略時はRも省略できる」を厳密に適用するなら 
    //   res = res.replace(/^RID(?=[SUVP]|$)/, "R") 等の調整が可能です。

    return res;
}

// --- 動作確認 ---

const samples = [
    {
        type: 'R',
        bits: { time: 0, random: 128 },
        radix: 64,
        flags: { S: false, U: false, V: false, P: false }
    },
    {
        type: 'T',
        bits: { time: 48, random: 16 },
        radix: 32,
        flags: { S: true, U: false, V: true, P: false }
    },
    {
        type: 'R',
        bits: { time: 0, random: 256 },
        radix: 1048576,
        flags: { S: false, U: false, V: false, P: true }
    }
];

samples.forEach(s => {
    const meta = stringifyIdMetadata(s);
    console.log(`Object: {type:${s.type}, bits:${s.bits.time}-${s.bits.random}, radix:${s.radix}}`);
    console.log(`Result: ${meta}`);
    console.log('---');
});
```

# 修正要求

　私が提示した仕様に誤りがありました。「`{radix}`|`2`〜`64`, `256`, `U`のいずれか」と言いましたが、その`U`は、`RID128F-乱数`の時に示した`F`のことを指しています。つまり正しくは「`{radix}`|`2`〜`64`, `256`, `F`のいずれか」でした。これは途中で`flag`の`U`と重複することに気づいて`F`に変更したのに、それを修正し忘れていたせいです。先述のコードには不要な`U`が含まれうる実装になってしまっています。これを踏まえて`parseIdMetadata`と`stringifyIdMetadata`の2つの関数を書き直してください。

```javascript
/**
 * IDメタデータの妥当性を判定し、解析結果を返す
 */
function parseIdMetadata(metaString) {
    // 正規表現の構成:
    // 1. ([RTI]) : Type (R, T, I)
    // 2. (?:ID)? : "ID"文字列（省略可）
    // 3. (\d+(?:-\d+)?)? : bits部分 (省略可)
    // 4. (?:R(\d+)|(F))? : radix部分。"R" + 数値、または "F" (省略可)
    // 5. ([SUVP]*) : Flags部分 (省略可)
    const pattern = /^([RTI])(?:ID)?(\d+(?:-\d+)?)?(?:R(\d+)|(F))?([SUVP]*)$/;
    const match = metaString.match(pattern);

    if (!match) return null;

    let [_, type, bitsPart, radixNum, isFull, flagsStr] = match;

    // --- bits の解析 ---
    let bits = { time: 0, random: 0 };
    if (type === 'T') {
        if (bitsPart && bitsPart.includes('-')) {
            const [t, r] = bitsPart.split('-').map(Number);
            bits.time = t;
            bits.random = r;
        } else {
            const total = bitsPart ? parseInt(bitsPart, 10) : 128;
            bits.time = 48; // Timedのデフォルト最小
            bits.random = total - 48;
        }
        if (bits.time < 48 || bits.random < 0) return null;
    } else {
        if (bitsPart && bitsPart.includes('-')) return null; // R,Iではハイフン形式不可
        bits.random = bitsPart ? parseInt(bitsPart, 10) : 128;
        if (bits.random < 8) return null;
    }

    // --- radix の解析 ---
    let radix;
    if (isFull) {
        radix = 1048576; // 'F' 指定時
    } else if (radixNum) {
        radix = parseInt(radixNum, 10);
        const allowed = (radix >= 2 && radix <= 64) || radix === 256;
        if (!allowed) return null;
    } else {
        radix = 64; // デフォルト
    }

    // --- flags の解析 ---
    const flagSet = new Set(flagsStr);
    if (flagSet.size !== flagsStr.length) return null; // 重複禁止

    return {
        type,
        bits,
        radix,
        flags: {
            S: flagSet.has('S'),
            U: flagSet.has('U'),
            V: flagSet.has('V'),
            P: flagSet.has('P')
        }
    };
}

/**
 * 解析オブジェクトから最短のメタデータ文字列を生成する
 */
function stringifyIdMetadata(obj) {
    const { type, bits, radix, flags } = obj;
    let res = type + "ID";

    // --- bits 部分 ---
    if (type === 'T') {
        if (bits.time === 48 && bits.random === 80) {
            // デフォルト128(48-80)なら省略
        } else {
            res += `${bits.time}-${bits.random}`;
        }
    } else {
        if (bits.random !== 128) {
            res += bits.random;
        }
    }

    // --- radix 部分 ---
    if (radix === 1048576) {
        res += "F";
    } else if (radix === 64) {
        // デフォルトなら省略
    } else if (radix) {
        res += "R" + radix;
    }

    // --- flags 部分 ---
    if (flags) {
        ['S', 'U', 'V', 'P'].forEach(f => {
            if (flags[f]) res += f;
        });
    }

    return res;
}

// --- 検証 ---
const testCases = [
    "RID128R64",    // 基本
    "RID128F",      // Radix 1048576 (F)
    "RIDSUVP",      // bits, radix省略 + flag U含む
    "TID48-80F",    // Timed + F
    "TID128R32U",   // Timed + Radix 32 + flag U
    "RID128RU"      // ❌ Invalid (radix Uは廃止、flag UならRID128U)
];

console.log("--- Parse Test ---");
testCases.forEach(tc => {
    const parsed = parseIdMetadata(tc);
    console.log(`${tc.padEnd(12)} -> ${parsed ? JSON.stringify(parsed) : "null"}`);
});

console.log("\n--- Stringify Test (Round-trip) ---");
const sampleObj = {
    type: 'R',
    bits: { time: 0, random: 128 },
    radix: 64,
    flags: { S: false, U: true, V: false, P: false }
};
console.log("Input Obj (Radix 64, Flag U):", JSON.stringify(sampleObj));
console.log("Result String:", stringifyIdMetadata(sampleObj)); // RIDU
```

# 修正要求

　テストデータ"RID32"の時にradix=32にならずbits.random=32になってしまいます。これを修正できますか？　それとも32がbitsなのかradixなのか区別できませんか？　先の省略可である仕様を考慮して実装可能か判断し、可能なら`parseIdMetadata`と`stringifyIdMetadata`の2つの関数を書き直してください。

```
結論から申し上げますと、「数字のみが置かれた場合に、それが bits なのか radix なのか」という問題は、文脈（前に R があるか、後ろに SUVP があるか等）を厳密にルール化することで解決可能です。
ご提示いただいた仕様「RID32 は bits=128, radix=32 である（bits省略時、Rも省略できる）」を優先し、以下の優先順位でパースするようにロジックを修正しました。
解析の優先ルール（修正版）

    R + 数字 があれば、それは確実に radix です。
    ID + 数字 があり、その後に R や F や SUVP が続くなら、その数字は bits です。
    ID 直後の数字のみ で、他に情報がない場合（例: RID32）：
        仕様に基づき「bitsを省略するとRも省略できる」＝ radix とみなします。
```


```javascript
/**
 * IDメタデータの妥当性を判定し、解析結果を返す
 */
function parseIdMetadata(metaString) {
    // 改良版正規表現
    // 1. type: ([RTI])
    // 2. ID文字列: (ID)?
    // 3. bits候補: (\d+(?:-\d+)?)?
    // 4. radix候補: (?:R(\d+)|(F))?
    // 5. flag候補: ([SUVP]*)
    const pattern = /^([RTI])(ID)?(\d+(?:-\d+)?)?(?:R(\d+)|(F))?([SUVP]*)$/;
    const match = metaString.match(pattern);

    if (!match) return null;

    let [_, type, hasId, rawNum, radixNum, isFull, flagsStr] = match;

    let bits = { time: 0, random: 0 };
    let radix = 64;

    // --- ロジックの要：rawNum(ID直後の数字) が bits か radix かの判定 ---
    let finalBitsPart = null;
    let finalRadixPart = radixNum;

    if (rawNum) {
        // もし R+数字 (radixNum) が既にあり、かつ ID+数字 (rawNum) があるなら、rawNum は bits
        if (radixNum || isFull) {
            finalBitsPart = rawNum;
        } 
        // フラグがある場合も、前の数字は bits とみなすのが一般的だが、
        // 「RID32SUVP」は radix=32 の仕様なので、後ろにフラグがあっても radix 優先
        else {
            // 仕様: RID32 は radix=32。つまり R が省略された形。
            finalRadixPart = rawNum;
            finalBitsPart = null; // bitsはデフォルトへ
        }
    }

    // --- bits の確定 ---
    if (type === 'T') {
        const val = finalBitsPart || "128"; // デフォルト128
        if (val.includes('-')) {
            const [t, r] = val.split('-').map(Number);
            bits.time = t; bits.random = r;
        } else {
            const total = parseInt(val, 10);
            bits.time = 48;
            bits.random = total - 48;
        }
        if (bits.time < 48 || bits.random < 0) return null;
    } else {
        if (finalBitsPart && finalBitsPart.includes('-')) return null;
        bits.random = finalBitsPart ? parseInt(finalBitsPart, 10) : 128;
        if (bits.random < 8) return null;
    }

    // --- radix の確定 ---
    if (isFull) {
        radix = 1048576;
    } else if (finalRadixPart) {
        radix = parseInt(finalRadixPart, 10);
        if (!((radix >= 2 && radix <= 64) || radix === 256)) return null;
    }

    // --- flags の確定 ---
    const flagSet = new Set(flagsStr);
    if (flagSet.size !== flagsStr.length) return null;

    return {
        type, bits, radix,
        flags: { S: flagSet.has('S'), U: flagSet.has('U'), V: flagSet.has('V'), P: flagSet.has('P') }
    };
}

/**
 * 解析オブジェクトから最短のメタデータ文字列を生成する
 */
function stringifyIdMetadata(obj) {
    const { type, bits, radix, flags } = obj;
    let res = type + "ID";

    const isDefaultBits = (type === 'T') ? (bits.time === 48 && bits.random === 80) : (bits.random === 128);
    const isDefaultRadix = (radix === 64);

    // bits がデフォルトでない場合のみ bits を出力
    if (!isDefaultBits) {
        res += (type === 'T') ? `${bits.time}-${bits.random}` : bits.random;
    }

    // radix の処理
    if (radix === 1048576) {
        res += "F";
    } else if (!isDefaultRadix) {
        // 仕様: bits省略時は R も省略できる
        if (isDefaultBits) {
            res += radix; // RID32 のような形式
        } else {
            res += "R" + radix; // RID256R32 のような形式
        }
    }

    // flags
    ['S', 'U', 'V', 'P'].forEach(f => { if (flags[f]) res += f; });

    return res;
}

// --- テスト ---
let testCases = [
    "RID128R64",    // 基本
    "RID128F",      // Radix 1048576 (F)
    "RIDSUVP",      // bits, radix省略 + flag U含む
    "TID48-80F",    // Timed + F
    "TID128R32U",   // Timed + Radix 32 + flag U
    "RID128RU",     // ❌ Invalid (radix Uは廃止、flag UならRID128U)
    "RID",
    "RIDF",
    "RID32",        // bits=128, radix=32 であるべき
    "RID32SUVP",    // bits=128, radix=32, flags
    "RID128R32",    // bits=128, radix=32
    "RID256F",      // bits=256, radix=Full
    "TID48-16R32S", // Timed指定
    "RIDSUVP",      // bits=128, radix=64, flags
];

testCases.forEach(tc => {
    const p = parseIdMetadata(tc);
    console.log(`${tc.padEnd(15)} -> bits:${(p?.bits.time||0)+(p?.bits.random||0)}, radix:${p?.radix}, flags:${JSON.stringify(p?.flags)}`);
    if(p) console.log(`   Re-gen: ${stringifyIdMetadata(p)}`);
});
```

# 修正要求

　`timeBitsと`randBits`を分離した形`bits:{time:N, random:N}`で`return`する仕様が消されてします。それも盛り込んだコードにして先程の修正をしてください。

```javascript
/**
 * IDメタデータの妥当性を判定し、解析結果を返す
 */
function parseIdMetadata(metaString) {
    // 1:Type, 2:ID(固定文字列), 3:数値(bitsかradix), 4:R+数値(明示的radix), 5:F(Full), 6:flags
    const pattern = /^([RTI])(ID)?(\d+(?:-\d+)?)?(?:R(\d+)|(F))?([SUVP]*)$/;
    const match = metaString.match(pattern);

    if (!match) return null;

    let [_, type, hasId, rawNum, explicitRadix, isFull, flagsStr] = match;

    let bits = { time: 0, random: 0 };
    let radix = 64;

    // --- bits と radix の振り分けロジック ---
    let bitsPart = null;
    let radixPart = explicitRadix;

    if (rawNum) {
        // 明示的な基数指定(R32やF)が後ろにあるなら、前の数字(rawNum)は確実にbits
        if (explicitRadix || isFull) {
            bitsPart = rawNum;
        } 
        // 後ろに基数指定がない場合、仕様により「bits省略時はRも省略可」＝ radixとみなす
        else {
            radixPart = rawNum;
            bitsPart = null; // bitsはデフォルト(128)へ
        }
    }

    // --- bitsオブジェクトの構築 ---
    if (type === 'T') {
        const val = bitsPart || "128"; // 省略時は合計128
        if (val.includes('-')) {
            const [t, r] = val.split('-').map(Number);
            bits.time = t;
            bits.random = r;
        } else {
            const total = parseInt(val, 10);
            bits.time = 48; // Timedデフォルト
            bits.random = total - 48;
        }
        if (bits.time < 48 || bits.random < 0) return null;
    } else {
        if (bitsPart && bitsPart.includes('-')) return null; // R,Iでハイフン不可
        bits.time = 0;
        bits.random = bitsPart ? parseInt(bitsPart, 10) : 128;
        if (bits.random < 8) return null;
    }

    // --- radixの確定 ---
    if (isFull) {
        radix = 1048576;
    } else if (radixPart) {
        radix = parseInt(radixPart, 10);
        if (!((radix >= 2 && radix <= 64) || radix === 256)) return null;
    }

    // --- flagsの確定 ---
    const flagSet = new Set(flagsStr);
    if (flagSet.size !== flagsStr.length) return null;

    return {
        type,
        bits,
        radix,
        flags: {
            S: flagSet.has('S'),
            U: flagSet.has('U'),
            V: flagSet.has('V'),
            P: flagSet.has('P')
        }
    };
}

/**
 * 解析オブジェクトから最短のメタデータ文字列を生成する
 */
function stringifyIdMetadata(obj) {
    const { type, bits, radix, flags } = obj;
    let res = type + "ID";

    const isDefaultBits = (type === 'T') 
        ? (bits.time === 48 && bits.random === 80) 
        : (bits.time === 0 && bits.random === 128);
    const isDefaultRadix = (radix === 64);

    // bitsがデフォルトでない場合のみ出力
    if (!isDefaultBits) {
        if (type === 'T') {
            res += `${bits.time}-${bits.random}`;
        } else {
            res += bits.random;
        }
    }

    // radixの出力
    if (radix === 1048576) {
        res += "F";
    } else if (!isDefaultRadix) {
        // bitsが省略されている場合は R も省略可能 (RID32 形式)
        // bitsがある場合は区別のため R をつける (RID256R32 形式)
        if (isDefaultBits) {
            res += radix;
        } else {
            res += "R" + radix;
        }
    }

    // flags
    ['S', 'U', 'V', 'P'].forEach(f => {
        if (flags[f]) res += f;
    });

    return res;
}

// --- テスト実行 ---
let testCases = [
    "RID128R64",    // 基本
    "RID128F",      // Radix 1048576 (F)
    "RIDSUVP",      // bits, radix省略 + flag U含む
    "TID48-80F",    // Timed + F
    "TID128R32U",   // Timed + Radix 32 + flag U
    "RID128RU",     // ❌ Invalid (radix Uは廃止、flag UならRID128U)
    "RID",
    "RIDF",

    "RID32",          // bits:{time:0, random:128}, radix:32
    "RID32SUVP",      // bits:{time:0, random:128}, radix:32 + flags
    "RID256R32",      // bits:{time:0, random:256}, radix:32
    "TID48-128F",     // bits:{time:48, random:128}, radix:1048576
    "TID",            // bits:{time:48, random:80}, radix:64 (デフォルト)
    "RIDSUVP"         // bits:{time:0, random:128}, radix:64 + flags
];

testCases.forEach(tc => {
    const p = parseIdMetadata(tc);
    if (p) {
        console.log(`Input: ${tc}`);
        console.log(`  Parsed -> type:${p.type}, bits:{time:${p.bits.time}, random:${p.bits.random}}, radix:${p.radix}, flags:${JSON.stringify(p?.flags)}`);
        console.log(`  String -> ${stringifyIdMetadata(p)}`);
    } else {
        console.log(`Input: ${tc} -> ❌ Invalid`);
    }
});
```

# 追加依頼

　以下「id-head.js」ファイルにランダムIDのメタデータを妥当判定するコードを書きました。これをBunでテストするコードを書いてください。特に大量にある有効な全パターン文字列の確認と、全例外発生時の確認をするコードを書いてください。一つたりともヌケモレがないように。長大なコードになると思いますが、出力制約などが有る場合でも分割するなど何とか回避してください。できないなら、なぜできないか教えてください。

```javascript
class IdError extends Error {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdError'}}
class IdDecordError extends IdError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdDecordError'}}
class IdEncordError extends IdError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdEncordError '}}
class IdHeadDecordError extends IdDecordError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdHeadDecordError'}}
class IdHeadEncordError extends IdEncordError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdHeadEncordError '}}
class IdBodyDecordError extends IdDecordError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdBodyDecordError'}}
class IdBodyEncordError extends IdEncordError {constructor(msg, cause) {cause ? super(msg, cause) : super(msg); this.name='IdBodyEncordError '}}
class IdHead {// 'RID128B64SUVP'のようなIDの型を示す文字列
    /**
     * IDメタデータの妥当性を判定し、詳細な構成を返す
     * @param {string} headString - ハイフン（乱数セパレータ）より前の文字列
     * @returns {object|null} 妥当なら解析オブジェクト、不当ならnull
     */
    static decode(headString) {
        // 1:Type, 2:ID(固定文字列), 3:数値(bitsかradix), 4:R+数値(明示的radix), 5:F(Full), 6:flags
        const pattern = /^([RTI])(ID)?(\d+(?:-\d+)?)?(?:R(\d+)|(F))?([SUVP]*)$/;
        const match = headString.match(pattern);

        //if (!match) return null;
        if (!match) {throw new IdHeadDecordError(`head文字列が不正です。次の正規表現に従ってください。${pattern}`)};

        let [_, type, hasId, rawNum, explicitRadix, isFull, flagsStr] = match;

        let bits = { time: 0, random: 0 };
        let radix = 64;

        // --- bits と radix の振り分けロジック ---
        let bitsPart = null;
        let radixPart = explicitRadix;

        if (rawNum) {
            // 明示的な基数指定(R32やF)が後ろにあるなら、前の数字(rawNum)は確実にbits
            if (explicitRadix || isFull) {
                bitsPart = rawNum;
            } 
            // 後ろに基数指定がない場合、仕様により「bits省略時はRも省略可」＝ radixとみなす
            else {
                radixPart = rawNum;
                bitsPart = null; // bitsはデフォルト(128)へ
            }
        }

        // --- bitsオブジェクトの構築 ---
        if (type === 'T') {
            const val = bitsPart || "128"; // 省略時は合計128
            if (val.includes('-')) {
                const [t, r] = val.split('-').map(Number);
                bits.time = t;
                bits.random = r;
            } else {
                const total = parseInt(val, 10);
                bits.time = 48; // Timedデフォルト
                bits.random = total - 48;
            }
//            if (bits.time < 48 || bits.random < 0) return null;
            if (bits.time < 48 || bits.random < 0) {throw new IdHeadDecordError(`timeBitsは48未満かrandomBitsが0以下です。各bitsを増やしてください。`)}
        } else {
            if (bitsPart && bitsPart.includes('-')) return null; // R,Iでハイフン不可
            bits.time = 0;
            bits.random = bitsPart ? parseInt(bitsPart, 10) : 128;
//            if (bits.random < 8) return null;
            if (bits.random < 8) {throw new IdHeadDecordError(`randomBitsが8より小さいです。増やしてください。`)}
        }

        // --- radixの確定 ---
        if (isFull) {
            radix = 1048576;
        } else if (radixPart) {
            radix = parseInt(radixPart, 10);
            //if (!((radix >= 2 && radix <= 64) || radix === 256)) return null;
            if (!((radix >= 2 && radix <= 64) || radix === 256)) {throw new IdHeadDecordError(`radixが不正値です。2〜64か256の整数かFのみ有効です。: ${radix}`)}
        }

        // --- flagsの確定 ---
        const flagSet = new Set(flagsStr);
//        if (flagSet.size !== flagsStr.length) return null;
        if (flagSet.size !== flagsStr.length) {throw new IdHeadDecordError(`flagが不正値です。SUVPの4字のみ有効です。: ${flagStr}`)}

        return {
            type,
            bits,
            radix,
            flags: {
                S: flagSet.has('S'),
                U: flagSet.has('U'),
                V: flagSet.has('V'),
                P: flagSet.has('P')
            }
        };
    }
    /**
     * 解析オブジェクトからメタデータ文字列を生成する
     * @param {object} obj - type, bits, radix, flags を持つオブジェクト
     * @returns {string} メタデータ文字列
     */
    static encode(obj) {
        const { type, bits, radix, flags } = obj;
        let res = type + "ID";

        const isDefaultBits = (type === 'T') 
            ? (bits.time === 48 && bits.random === 80) 
            : (bits.time === 0 && bits.random === 128);
        const isDefaultRadix = (radix === 64);

        // bitsがデフォルトでない場合のみ出力
        if (!isDefaultBits) {
            if (type === 'T') {
                res += `${bits.time}-${bits.random}`;
            } else {
                res += bits.random;
            }
        }

        // radixの出力
        if (radix === 1048576) {
            res += "F";
        } else if (!isDefaultRadix) {
            // bitsが省略されている場合は R も省略可能 (RID32 形式)
            // bitsがある場合は区別のため R をつける (RID256R32 形式)
            if (isDefaultBits) {
                res += radix;
            } else {
                res += "R" + radix;
            }
        }

        // flags
        ['S', 'U', 'V', 'P'].forEach(f => {
            if (flags[f]) res += f;
        });

        return res;
    }
    constructor(str) {
        this._ = IdHead.decode(str);
    }
    get type() {return this._.type}
    get timeBits() {return this._.bits.time}
    get randomBits() {return this._.bits.random}
    get radix() {return this._.radix}
    get sortable() {return this._.S}
    get urlUnsafed() {return this._.U}
    get visibled() {return this._.V}
    get padded() {return this._.P}
}
export {IdError,IdDecordError,IdEncordError,IdHeadDecordError,IdHeadEncordError,IdBodyDecordError,IdBodyEncordError,IdHead};
```
